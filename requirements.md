Technical Product Requirement Document: "SubTrack" – Privacy-First Subscription & Expense Manager1. Market Viability and Strategic Gap AnalysisThe contemporary personal finance application landscape is dominated by two primary archetypes: the aggregator and the manual tracker. The aggregator model, exemplified by market leaders such as Rocket Money (formerly Truebill) and Mint (defunct, succeeded by Credit Karma), relies heavily on the Open Banking paradigm. These applications necessitate that users authenticate via third-party APIs like Plaid or Yodlee, granting continuous read-access to their banking institutions.1 While this offers the convenience of automated ingestion, it creates a significant privacy liability that a growing segment of the user base finds unacceptable. The manual tracker model, conversely, requires high-friction user input for every transaction, leading to "tracker fatigue" and eventual churn.This dichotomy creates a distinct market gap for a "hybrid automation" solution—an application that offers the ease of automation without the privacy intrusion of bank linking. This gap is further widened by the technical capabilities of modern mobile operating systems. Android’s NotificationListenerService 3 and iOS’s VisionKit 5 allow for the local interception and parsing of transaction data (SMS alerts, push notifications, and screenshots) without that data ever leaving the device. This "Local-First" architecture aligns with the increasing consumer demand for data sovereignty and privacy, a trend accelerated by regulatory frameworks like GDPR and CCPA.1.1 The "Privacy Paradox" in FintechThe viability of a privacy-first subscription manager rests on the "Privacy Paradox," where users express deep concern for their data privacy yet often trade it for convenience. However, in the domain of financial data, this trade-off is becoming less palatable. Research indicates that a significant demographic—specifically tech-savvy millennials and Gen Z users—are actively seeking "zero-knowledge" financial tools. By processing data exclusively on-device, SubTrack addresses this demographic's core anxiety: the fear of data breaches at the aggregator level. Unlike Rocket Money, which analyzes $40 billion in transaction volume on cloud servers 7, SubTrack’s value proposition is that the user’s financial graph exists solely on their physical device, encrypted and inaccessible even to the developers.1.2 The Shared Economy and Social Finance GapA secondary, yet critical, gap exists in the management of shared expenses. The gig economy and the rise of co-living arrangements have necessitated tools for splitting costs. Splitwise is the incumbent leader, yet its algorithmic approach to "debt simplification" is often opaque to users, and its integration with recurring subscriptions is weak.8 Users typically maintain a subscription tracker for personal bills and a separate app for shared household bills. SubTrack aims to unify these functions. By integrating a debt-simplification algorithm directly into the subscription engine, the system can automatically apportion a "Netflix" charge to four roommates and update their net balances without manual intervention. This addresses the "fragmented utility" problem where users must toggle between apps to manage a single financial life.1.3 The Freelancer Niche: Schedule C ComplianceA specific, high-value gap exists for freelancers and gig workers who must categorize expenses for tax purposes, specifically IRS Schedule C.10 Most general-purpose trackers lack the specific tagging required to distinguish between personal and business use of software subscriptions (e.g., Adobe Creative Cloud, GitHub Copilot). By implementing strict categorization based on IRS guidelines—distinguishing between "Office Expenses," "Rent of Business Property," and "Utilities"—SubTrack can serve as a lightweight accounting tool.11 This feature set justifies a premium price point, as it directly translates to tax savings and reduced administrative burden for the user.Feature GapCompetitor A (Aggregators)Competitor B (Manual Trackers)SubTrack (Proposed)Data PrivacyLow (Server-side analysis)High (Local storage)Maximum (Local + Automation)Input MethodAPI Linking (Plaid)Manual TypingSMS/OCR ParsingShared FinanceLimited / Non-existentBasic SplittingGraph-based SimplificationTax FeaturesGeneric CategorizationNoneSchedule C MappingMonetizationData Sales / SubsOne-time / AdsUtility Subscription2. System Architecture and Design PhilosophyThe architectural foundation of SubTrack is predicated on the "Local-First" methodology, utilizing a Clean Architecture pattern organized by features rather than technical layers. This approach ensures scalability, testability, and a strict separation of concerns, which is vital when managing complex platform-specific logic like Android Services and iOS Vision frameworks alongside shared business logic.132.1 Clean Architecture with Feature-First StructureThe codebase will be structured to isolate the domain logic from the UI and data sources. Unlike traditional layer-first approaches (grouping all controllers together), the feature-first approach groups files by their functional domain (e.g., subscription_detection, expense_splitting). This allows for modular development where the Android notification logic remains encapsulated within the subscription_detection feature, interacting with the rest of the app solely through defined Domain interfaces.Presentation Layer: Responsible for the UI and state management. It observes the Domain layer and renders data. It utilizes ConsumerWidget classes from Riverpod to reactively rebuild interfaces upon state changes.15Domain Layer: The core of the application. It contains Entities (e.g., Subscription, Transaction), Value Objects (e.g., Currency, Category), and abstract Use Cases (e.g., ParseSmsUseCase, SimplifyDebtsUseCase). This layer is pure Dart, with no dependencies on Flutter, Android, or iOS SDKs, ensuring that business logic is platform-agnostic.Data Layer: Handles data retrieval and persistence. It implements the Repository interfaces defined in the Domain layer. This is where the concrete implementations of Drift database calls, MethodChannel invocations for Android, and VisionKit bridges for iOS reside.2.2 State Management Strategy: Riverpod 2.0The application will utilize Riverpod for state management and dependency injection, specifically leveraging the riverpod_generator package to enforce type safety and reduce boilerplate.15NotifierProvider: Used for synchronous state that requires mutation, such as the current "Add Subscription" form data or the active filter settings on the dashboard.AsyncNotifierProvider: Essential for handling asynchronous data operations, such as fetching the list of subscriptions from the SQLite database. This provider handles the loading, error, and data states intrinsically, allowing the UI to gracefully handle database latency.StreamProvider: This is critical for the "Real-Time" aspect of the app. It will subscribe to the stream of incoming SMS/Notification events from the Android Native layer. As the NotificationListenerService detects a new financial transaction, it pushes an event to the EventChannel, which the StreamProvider consumes to trigger a "New Transaction Detected" alert in the UI without requiring a manual refresh.2.3 Data Persistence: Drift (SQLite)Drift (formerly Moor) is selected as the persistence solution due to its type-safe Dart API and robust SQL support.16 Unlike NoSQL solutions (e.g., Hive), Drift allows for complex relational queries, which are required for the expense-splitting feature. The database schema must support many-to-many relationships between Users and Transactions to accurately calculate debts.The database architecture includes a strict schema definition with foreign key constraints to ensure data integrity. For instance, a Transaction must belong to a Category, and a Split must reference a valid User and Transaction. Drift’s support for DAOs (Data Access Objects) allows us to separate the database logic for subscriptions from the logic for users and groups, maintaining the modular architecture.2.4 Security ArchitectureGiven the sensitive nature of financial data, the application employs a multi-layered security strategy.At-Rest Encryption: While SQLite databases are stored in the app's private sandbox, SubTrack will implement field-level encryption for sensitive columns (e.g., the last 4 digits of a card number or user notes). The encryption keys will be generated securely and stored in the device's hardware-backed secure element via flutter_secure_storage.18 This ensures that even if the device is rooted/jailbroken and the database file is extracted, the sensitive text fields remain unreadable without the hardware key.Biometric Authentication: The app will implement local_auth to gate access to the UI. Upon launch or resume, the app will request FaceID (iOS) or Fingerprint (Android) verification.20 This utilizes the platform's BiometricPrompt API, ensuring that biometric data never leaves the secure enclave.3. Platform-Specific Implementation: AndroidThe Android implementation is the cornerstone of the "zero-input" promise. It leverages the operating system's notification framework to intercept transaction alerts in real-time. This requires a deep integration with the Android SDK, bypassing the limitations of the Flutter framework by writing native Kotlin code.3.1 The Notification Listener ServiceThe core component is a service extending android.service.notification.NotificationListenerService.3 This abstract class allows the application to receive calls from the system whenever a notification is posted or removed.3.1.1 Service Lifecycle and RegistrationThe service must be declared in the AndroidManifest.xml with the BIND_NOTIFICATION_LISTENER_SERVICE permission. This is a high-privilege permission that requires explicit user approval via the system settings. The app must implement a user-friendly onboarding flow that guides the user to the "Device & App Notifications" settings screen to grant this access.Once active, the onNotificationPosted method is triggered for every notification on the device. To preserve battery life and privacy, the service immediately filters notifications based on the packageName. Only packages from known banking applications (e.g., com.chase.sig.android), digital wallets (e.g., com.google.android.apps.walletnfcrel), and SMS handlers (e.g., com.google.android.apps.messaging) are processed. All others are ignored at the entry point.3.1.2 The StatusBarNotification ObjectThe listener receives a StatusBarNotification (SBN) object. The critical data resides in the Notification object within the SBN, specifically in the extras bundle.23 The app must extract:Notification.EXTRA_TITLE: Usually contains the sender name (e.g., "Chase", "PayPal").Notification.EXTRA_TEXT: Contains the message body (e.g., "You spent $15.99 at Netflix").Notification.EXTRA_BIG_TEXT: Used for longer notifications that might be truncated in the standard text field.The service must also implement logic to handle "Grouped Notifications" (stacks of alerts), iterating through the group summary to access individual transaction alerts.3.2 Regex Pattern Matching EngineThe raw text extracted from notifications is unstructured. To convert this into structured data (Merchant, Amount, Date), the app utilizes a robust Regex engine. While this parsing could theoretically happen in Kotlin, passing the raw string to the Dart layer allows for "Over-the-Air" (OTA) updates to regex patterns without requiring a full app store update.3.2.1 Pattern StrategyBanks use diverse and changing formats. The regex strategy employs a library of "fingerprints" for major institutions.Chase Bank Pattern: The pattern typically follows a structure of Chase:.* $(\d+\.\d{2}) at ([\w\s*]+). This regex captures the amount in group 1 and the merchant name in group 2.25Amex Pattern: American Express alerts often use the format Amex:.* charged $(\d+\.\d{2}) at ([\w\s]+). The engine must be case-insensitive ((?i)) to handle variations.26PayPal Pattern: PayPal notifications are distinct, often phrasing transactions as "You paid $[Amount] USD to [Merchant]". The regex (?i)You\s+paid\s+\$([\d\.]+)\s+USD\s+to\s+([\w\s]+) effectively captures these distinct groups.283.2.2 The "Generic" HeuristicFor unknown banks, the system falls back to a generic financial regex. This looks for keywords like "spent", "charged", "debit", or "purchase" in proximity to a currency symbol and a numeric value. While less accurate, this ensures coverage for long-tail credit unions. The regex (?i)(?:purchased|spent|charged)\s*(?:USD|rs|inr|£|\$)?\s*([\d,]+\.\d{2})\s*at\s*([\w\s]+) serves as this catch-all mechanism.3.3 Navigating Android 15 RestrictionsAndroid 15 introduces significant privacy hardening, specifically regarding "Sensitive Notifications" (OTPs, 2FA codes). The OS may redact the content of these notifications from NotificationListenerService unless the app holds a specific role (like a Companion Device) or the user explicitly disables "Enhanced Notifications" protection.29SubTrack must implement a detection mechanism for redacted notifications. If the service receives a notification from a banking app where EXTRA_TEXT is null or marked hidden, the app must trigger a UI alert explaining the situation. The user guide must explicitly instruct users to allow "Sensitive Content" for SubTrack in the Android settings, or alternatively, rely on the "Accessibility Service" as a fallback (though this is harder to justify to the Google Play review team). The primary strategy remains NotificationListenerService with clear user education on the new Android 15 toggles.3.4 Background Persistence and Method ChannelsTo ensure the listener survives device reboots, the app registers a BroadcastReceiver for android.intent.action.BOOT_COMPLETED. Upon boot, this receiver restarts the listener service.4Communication between the Kotlin service and the Flutter UI is handled via MethodChannel and EventChannel.3MethodChannel (com.subtrack.app/control): Used for command-response interactions, such as checking if the permission is granted (checkPermission) or launching the settings intent (openSettings).EventChannel (com.subtrack.app/stream): Used for the continuous stream of notification data. The Kotlin service creates an EventSink which pushes a JSON string every time a valid transaction is parsed. This JSON is then decoded by the Dart StreamProvider.4. Platform-Specific Implementation: iOSApple’s privacy sandbox strictly prohibits apps from reading notifications or SMS messages belonging to other applications. Consequently, the iOS implementation of SubTrack relies on a different mechanism: Optical Character Recognition (OCR) via the Vision framework. This "Pull" model requires the user to proactively provide input (screenshots or camera scans), unlike the "Push" model on Android.4.1 VisionKit and Document ScanningThe primary input vector on iOS is the VNDocumentCameraViewController.6 This native UIKit controller provides a sophisticated interface for scanning physical documents (bills, receipts). It automatically handles edge detection, perspective correction, and color filtering to produce a clean, flat image of the document.To integrate this into Flutter, we use UIViewControllerRepresentable. This wrapper allows the UIKit controller to be embedded within the Flutter widget tree. The makeUIViewController method instantiates the camera controller, while the updateUIViewController handles state changes. Crucially, the Coordinator (delegate) listens for the didFinishWith callback, which returns a VNDocumentCameraScan object containing the processed images.4.2 The OCR Pipeline: Vision FrameworkOnce an image is captured (or selected from the Photo Library), it enters the OCR pipeline utilizing the Vision framework.31Request Creation: The app creates a VNRecognizeTextRequest. This request is configured with .accurate recognition level (as opposed to .fast), prioritizing precision over speed, which is essential for reading financial digits. The recognitionLanguages property is set to prioritize the user's locale.Processing: A VNImageRequestHandler is instantiated with the CGImage data. The handler executes the text recognition request on a background thread to prevent blocking the main UI thread.Observation Analysis: The result of the request is an array of VNRecognizedTextObservation objects. Each observation contains a topCandidates array. The app extracts the string with the highest confidence score.4.3 Heuristic Data ExtractionThe raw text output from Vision is a "soup" of strings (e.g., "Comcast", "Total", "$105.00", "Due Date", "Jan 15"). SubTrack employs a heuristic parsing logic to make sense of this data.Amount Detection: The parser scans for currency symbols ($) and decimal patterns. It prioritizes the largest numerical value found on the bottom half of the document, assuming this represents the "Total Due."Date Detection: It searches for date patterns (MM/DD/YYYY, Mon DD, YYYY) and context keywords like "Due", "Billing Date", or "Statement Date."Merchant Identification: The text is cross-referenced against a local SQLite table of known merchants. If "Netflix" appears in the scanned text, it is tagged as the merchant. If no match is found, the largest text element at the top of the document is heuristically guessed to be the merchant name.5. Core Logic: Debt Simplification EngineA key differentiator for SubTrack is its ability to manage shared finances for groups (roommates, couples). The core challenge in this domain is minimizing the number of transactions required to settle debts. If A owes B $10, B owes C $10, and C owes A $10, the net flow is zero, and no money should change hands. SubTrack solves this using a graph-theoretic approach known as "Debt Simplification" or "Minimum Cash Flow".335.1 Graph Theory FundamentalsThe group's financial state is modeled as a directed graph where vertices represent users and edges represent debts. The weight of an edge (u, v) represents the amount user u owes user v. The goal is to transform this graph into an equivalent graph (where net balances remain unchanged) with the minimum number of edges (transactions).5.2 The Greedy Algorithm ImplementationSubTrack implements a greedy algorithm to solve this problem efficiently. While the optimal solution is NP-Complete, the greedy approach provides a highly effective approximation that is computationally inexpensive for small groups (N < 20).Net Balance Calculation: The algorithm iterates through all expenses to calculate the net balance for each user.$$Net_u = \sum \text{Incoming}_u - \sum \text{Outgoing}_u$$A positive net balance indicates the user is a creditor (owed money), while a negative balance indicates a debtor (owes money).Partitioning: Users are separated into two lists: Debtors ($Net < 0$) and Creditors ($Net > 0$). Users with a net balance of zero are removed from the calculation.Greedy Matching: The lists are sorted by absolute value magnitude.The algorithm selects the Debtor with the largest debt ($D_{max}$) and the Creditor with the largest credit ($C_{max}$).The transaction amount $T$ is determined by $T = \min(|D_{max}|, C_{max})$.A transaction is generated: "$D_{max}$ pays $C_{max}$ amount $T$."The balances are updated: $Net_{Dmax} += T$, $Net_{Cmax} -= T$.If a user's balance reaches zero, they are removed from the set.The process repeats until all balances are zero.5.3 Edge Cases and OptimizationsMulti-Currency Handling: The algorithm requires a unified base currency. SubTrack integrates a currency converter (using cached exchange rates) to normalize all expenses to the group's default currency before running the simplification logic.Cyclical Debts: The greedy nature of the algorithm inherently eliminates cycles (A->B->C->A) because it operates on net balances, where cyclical debts cancel out mathematically before the matching phase begins.Inequality: The split logic supports unequal shares (e.g., User A pays 60%, User B pays 40%). These are handled during the initial net balance calculation phase, ensuring the simplification engine works on the final resulting debt, regardless of how the original expense was divided.6. Regulatory Compliance and Tax FeaturesThe "Gig Economy" has created a demographic of users who require sophisticated tax tracking. SubTrack addresses this by integrating features specifically designed for IRS Schedule C compliance.106.1 Schedule C CategorizationThe Internal Revenue Service (IRS) categorizes business expenses into specific buckets (e.g., Advertising, Legal/Professional Services, Office Expense). SubTrack includes a pre-populated list of these categories. When a user toggles "Business Expense" on a subscription (e.g., Adobe Creative Cloud), the app prompts them to map it to a Schedule C line item (e.g., "Rent or lease of other business property" for software licenses).356.2 Data Portability and AuditingTo support tax filing, the application includes a CSV export engine. This engine queries the Drift database for all transactions flagged is_tax_deductible within a user-specified date range (typically the fiscal year). The generated CSV is formatted to be compatible with major accounting software (QuickBooks, Xero) and includes columns for Date, Merchant, Amount, Schedule C Category, and a link to the locally stored receipt image (if available). This feature transforms the app from a simple tracker into a professional tool for freelancers.7. Monetization and Revenue StrategyThe viability analysis suggests that a pure "Subscription Tracker" has low monetization potential due to feature commoditization. However, by positioning SubTrack as a "Financial Automation Tool" with tax benefits, the value proposition shifts significantly.7.1 Freemium Model StructureFree Tier: Designed for user acquisition and retention.36 Includes manual tracking, basic dashboarding, and local storage. This replaces the "Excel Spreadsheet" for the casual user.Premium Tier ($4.99/month): Monetizes the "Convenience" and "Professional" aspects.Automation: Unlocks the Android Notification Listener and iOS OCR scanner. This saves the user time, justifying the recurring cost.Tax Engine: Unlocks Schedule C categorization and CSV exporting. For a freelancer, saving even one hour of tax prep time pays for the annual subscription.Unlimited Groups: Allows managing multiple shared expense groups (e.g., "Apartment", "Trip to Cabo", "Family").7.2 Implementation with RevenueCatTechnical implementation of subscriptions is handled via RevenueCat.37 This middleware abstracts the complexities of the Google Play Billing Library and Apple StoreKit. It handles receipt validation, entitlement tracking, and subscription status synchronization across devices (if the user opts into cloud backup). This ensures that a user who upgrades on their Android phone retains their premium status if they switch to an iPad.8. Quality Assurance and Testing StrategyGiven the financial nature of the application, correctness is paramount. A bug in the debt simplification algorithm could cause users to lose money, destroying trust.8.1 Unit Testing: The Regex CorpusThe reliability of the Android SMS parser depends on the Regex engine. The testing strategy involves maintaining a massive corpus of anonymized SMS strings from hundreds of banks.Test Suite: A parameterized unit test iterates through thousands of sample SMS messages, asserting that the Regex engine correctly extracts the Amount, Merchant, and Date.Regression Testing: Every time a regex pattern is updated (e.g., to support a new Chase Bank format), the entire corpus is re-run to ensure no regressions occurred for other banks.8.2 Algorithmic VerificationThe Debt Simplification algorithm is tested using property-based testing. Random graphs of debts are generated, and the algorithm is run.Invariant Check: The test asserts that the Net Balance of every user is identical before and after simplification. If Alice was net +$20 before simplification, she must be net +$20 after, regardless of who pays her. This mathematically guarantees that no money is created or lost during the process.8.3 Integration and UI TestingDatabase Integration: Integration tests spin up an in-memory instance of the Drift database to verify that cascading deletes work correctly (e.g., deleting a Group deletes all associated Splits).End-to-End UI: Tools like Maestro or Patrol are used to simulate user flows. A critical test flow involves a user granting Notification permissions, receiving a mock notification (via ADB), and verifying that a new transaction appears on the dashboard.9. ConclusionSubTrack represents a convergent evolution in personal finance apps. It synthesizes the automation of aggregators, the privacy of manual trackers, and the social logic of debt splitters into a single, cohesive unit. By architecting for "Local-First" data processing, it navigates the privacy paradox, offering users the convenience they crave without the surveillance they fear. The technical execution—spanning Android Services, iOS Vision frameworks, and Graph Theory algorithms—creates a robust barrier to entry for competitors and a high-value product for users, particularly in the underserved freelancer niche. This specification serves as the blueprint for engineering a tool that is not just viable, but vital, in the modern financial app ecosystem.Feature AreaTechnical RequirementStrategic JustificationParsingAndroid NotificationListener & iOS VisionKitEnables "Zero-Knowledge" automation (Privacy First).SplittingMin-Cash-Flow Algorithm (Greedy Heuristic)Solves the "Fragmented Utility" gap (Subscription + Splitting).TaxSchedule C Categorization & CSV ExportMonetizable feature targeting the Freelancer niche.ArchitectureFeature-First Clean Arch + RiverpodEnsures scalability and testability of complex logic.DatabaseDrift (SQLite)Provides relational integrity needed for complex splitting logic.